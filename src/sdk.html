<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta http-equiv="Content-Security-Policy" content="default-src * 'self' 'unsafe-inline' 'unsafe-eval' data: gap: http: https: ws: wss: https://ssl.gstatic.com; script-src * 'self' 'unsafe-inline' 'unsafe-eval' http: https:; style-src * 'self' 'unsafe-inline' http: https:; media-src * blob: 'self' 'unsafe-inline' http: https:; img-src * 'self' data: blob: http: https:; connect-src * 'self' http: https: ws: wss:;">
  <title>StorySDK</title>
  
  <!-- Preloading critical resources -->
  <link rel="preload" href="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js" as="script" crossorigin>
  <link rel="preload" href="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js" as="script" crossorigin>
  <link rel="preload" href="https://cdn.jsdelivr.net/npm/@storysdk/core@1.9.0/dist/bundle.css" as="style">
  
  <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@storysdk/core@1.9.0/dist/bundle.css" />
  
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      min-height: 110px;
      overflow: hidden;
    }
    #storysdk-container {
      width: 100%;
      min-height: 110px;
      height: auto;
    }
  </style>
</head>
<body>
  <div id="storysdk-container">
  </div>

  <script>
    // CRITICAL: Clear all SDK global variables to prevent cache issues
    (function clearSDKGlobals() {
      try {
        // Clear all SDK-related global variables
        delete window.__STORYSDK_INITIALIZED__;
        delete window.__STORYSDK_PREVIOUS_TOKEN__;
        delete window.__STORYSDK_INSTANCE__;
        delete window.__STORYSDK_WEBVIEW_READY_SENT__;
        delete window.__STORYSDK_API_PREVIOUS_TOKEN__;
        delete window.STORYSDK_DEBUG;
        delete window.__STORYSDK_USE_ASYNC_STORAGE_ONLY__;
        
        // Also clear Story constructor if exists to force fresh load
        delete window.Story;
        delete window.storysdk;
        
        console.log('StorySDK: Cleared all global variables to prevent cache issues');
      } catch (error) {
        console.warn('StorySDK: Error clearing global variables:', error);
      }
    })();

    // Bundle version for cache management
    const BUNDLE_VERSION = '1.9.3';
    
    // Simple hash function for tokens
    function simpleHash(str) {
      let hash = 0;
      if (str.length === 0) return hash.toString();
      
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32-bit integer
      }
      
      return Math.abs(hash).toString(36);
    }
    
    // Keys for local script caching (will be updated with token)
    let SCRIPT_CACHE_KEY = `storysdk:script:${BUNDLE_VERSION}`;
    let CSS_CACHE_KEY = `storysdk:css:${BUNDLE_VERSION}`;
    
    // Update cache keys with token hash
    function updateCacheKeys(token) {
      if (token) {
        const tokenHash = simpleHash(token);
        SCRIPT_CACHE_KEY = `storysdk:script:${BUNDLE_VERSION}:${tokenHash}`;
        CSS_CACHE_KEY = `storysdk:css:${BUNDLE_VERSION}:${tokenHash}`;
      }
    }
    
    // Clear storage cache for specific token
    async function clearTokenCache(tokenHash) {
      try {
        if (window.ReactNativeWebView) {
          // Send message to React Native to clear cache by token hash
          postMessageToReactNative('storysdk:cache:clear:token', {
            tokenHash: tokenHash,
            patterns: [`storysdk:*${tokenHash}*`, `storysdk_*${tokenHash}*`]
          });
        } else {
          // Fallback to localStorage
          const keysToRemove = [];
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('storysdk:') && key.includes(tokenHash)) {
              keysToRemove.push(key);
            }
          }
          keysToRemove.forEach(key => localStorage.removeItem(key));
        }
        debug('Cleared storage cache for token hash:', tokenHash);
      } catch (e) {
        debug('Error clearing token cache:', e);
      }
    }
    
    // Clear ALL SDK-related cache (more aggressive)
    async function clearAllSDKCache(preserveTokens = false) {
      try {
        if (window.ReactNativeWebView) {
          // Send message to React Native to clear all SDK cache
          // Exclude token patterns if preserveTokens is true
          const patterns = preserveTokens 
            ? ['storysdk:script:*', 'storysdk:css:*', 'storysdk:data:*', 'storysdk:cache:*', 'storysdk_*'] 
            : ['storysdk:*', 'storysdk_*'];
            
          postMessageToReactNative('storysdk:cache:clear:all', {
            patterns: patterns,
            preserveTokens: preserveTokens
          });
        } else {
          // Fallback to localStorage
          const keysToRemove = [];
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('storysdk:')) {
              // Skip token keys if preserveTokens is true
              if (preserveTokens && key.startsWith('storysdk:token:')) {
                continue;
              }
              keysToRemove.push(key);
            }
          }
          keysToRemove.forEach(key => localStorage.removeItem(key));
        }
        
        if (window.__STORYSDK_INITIALIZED__) {
          window.__STORYSDK_INITIALIZED__ = false;
        }
        if (window.__STORYSDK_WEBVIEW_READY_SENT__) {
          window.__STORYSDK_WEBVIEW_READY_SENT__ = false;
        }
        
        debug('Cleared all SDK cache and state', preserveTokens ? '(tokens preserved)' : '');
      } catch (e) {
        debug('Error clearing all SDK cache:', e);
      }
    }

    function checkBrowserCompatibility() {
      const requiredFeatures = {
        'Promise': typeof Promise !== 'undefined',
        'fetch': typeof fetch !== 'undefined',
        'JSON': typeof JSON !== 'undefined',
        'postMessage': typeof window.postMessage !== 'undefined'
      };

      const missingFeatures = Object.entries(requiredFeatures)
        .filter(([_, supported]) => !supported)
        .map(([feature]) => feature);

      if (missingFeatures.length > 0) {
        throw new Error(`Browser does not support required features: ${missingFeatures.join(', ')}`);
      }
    }

    function debug(message, data) {
      if (window.STORYSDK_DEBUG) {
        console.log(message, data);
      }
    }

    function postMessageToReactNative(type, data) {
      if (window.ReactNativeWebView) {
        const message = {
          type,
          data: data || {}
        };
        try {
          window.ReactNativeWebView.postMessage(JSON.stringify(message));
          debug('Message sent to React Native:', message);
        } catch (error) {
          debug('Error sending message to React Native:', error);
        }
      }
    }
    
    // Storage abstraction - uses AsyncStorage via messages when available
    const StorageProxy = {
      async getItem(key) {
        if (window.ReactNativeWebView && window.__STORYSDK_USE_ASYNC_STORAGE_ONLY__) {
          // Force use of AsyncStorage via React Native messages
          return new Promise((resolve) => {
            const callbackId = `get_${Date.now()}_${Math.random()}`;
            
            const handleMessage = (event) => {
              try {
                const response = JSON.parse(event.data);
                if (response.type === 'storysdk:storage:response' && response.callbackId === callbackId) {
                  window.removeEventListener('message', handleMessage);
                  resolve(response.data.value);
                }
              } catch (e) {
                // Ignore parsing errors
              }
            };
            
            window.addEventListener('message', handleMessage);
            
            window.ReactNativeWebView.postMessage(JSON.stringify({
              type: 'storysdk:storage:get',
              callbackId: callbackId,
              data: { key }
            }));
            
            // Timeout after 5 seconds
            setTimeout(() => {
              window.removeEventListener('message', handleMessage);
              resolve(null);
            }, 5000);
          });
        } else if (window.ReactNativeWebView) {
          // Use AsyncStorage via React Native messages
          return new Promise((resolve) => {
            const callbackId = `get_${Date.now()}_${Math.random()}`;
            
            const handleMessage = (event) => {
              try {
                const response = JSON.parse(event.data);
                if (response.type === 'storysdk:storage:response' && response.callbackId === callbackId) {
                  window.removeEventListener('message', handleMessage);
                  resolve(response.data.value);
                }
              } catch (e) {
                // Ignore parsing errors
              }
            };
            
            window.addEventListener('message', handleMessage);
            
            window.ReactNativeWebView.postMessage(JSON.stringify({
              type: 'storysdk:storage:get',
              callbackId: callbackId,
              data: { key }
            }));
            
            // Timeout after 5 seconds
            setTimeout(() => {
              window.removeEventListener('message', handleMessage);
              resolve(null);
            }, 5000);
          });
        } else {
          // Fallback to localStorage
          try {
            return localStorage.getItem(key);
          } catch (e) {
            return null;
          }
        }
      },
      
      async setItem(key, value) {
        if (window.ReactNativeWebView && window.__STORYSDK_USE_ASYNC_STORAGE_ONLY__) {
          // Force use of AsyncStorage via React Native messages
          return new Promise((resolve) => {
            const callbackId = `set_${Date.now()}_${Math.random()}`;
            
            const handleMessage = (event) => {
              try {
                const response = JSON.parse(event.data);
                if (response.type === 'storysdk:storage:response' && response.callbackId === callbackId) {
                  window.removeEventListener('message', handleMessage);
                  resolve(response.data.success || false);
                }
              } catch (e) {
                // Ignore parsing errors
              }
            };
            
            window.addEventListener('message', handleMessage);
            
            window.ReactNativeWebView.postMessage(JSON.stringify({
              type: 'storysdk:storage:set',
              callbackId: callbackId,
              data: { key, value }
            }));
            
            // Timeout after 5 seconds
            setTimeout(() => {
              window.removeEventListener('message', handleMessage);
              resolve(false);
            }, 5000);
          });
        } else if (window.ReactNativeWebView) {
          // Use AsyncStorage via React Native messages
          return new Promise((resolve) => {
            const callbackId = `set_${Date.now()}_${Math.random()}`;
            
            const handleMessage = (event) => {
              try {
                const response = JSON.parse(event.data);
                if (response.type === 'storysdk:storage:response' && response.callbackId === callbackId) {
                  window.removeEventListener('message', handleMessage);
                  resolve(response.data.success || false);
                }
              } catch (e) {
                // Ignore parsing errors
              }
            };
            
            window.addEventListener('message', handleMessage);
            
            window.ReactNativeWebView.postMessage(JSON.stringify({
              type: 'storysdk:storage:set',
              callbackId: callbackId,
              data: { key, value }
            }));
            
            // Timeout after 5 seconds
            setTimeout(() => {
              window.removeEventListener('message', handleMessage);
              resolve(false);
            }, 5000);
          });
        } else {
          // Fallback to localStorage
          try {
            localStorage.setItem(key, value);
            return true;
          } catch (e) {
            return false;
          }
        }
      },
      
      async removeItem(key) {
        if (window.ReactNativeWebView && window.__STORYSDK_USE_ASYNC_STORAGE_ONLY__) {
          // Force use of AsyncStorage via React Native messages
          return new Promise((resolve) => {
            const callbackId = `remove_${Date.now()}_${Math.random()}`;
            
            const handleMessage = (event) => {
              try {
                const response = JSON.parse(event.data);
                if (response.type === 'storysdk:storage:response' && response.callbackId === callbackId) {
                  window.removeEventListener('message', handleMessage);
                  resolve(response.data.success || false);
                }
              } catch (e) {
                // Ignore parsing errors
              }
            };
            
            window.addEventListener('message', handleMessage);
            
            window.ReactNativeWebView.postMessage(JSON.stringify({
              type: 'storysdk:storage:set',
              callbackId: callbackId,
              data: { key, value: null } // Setting to null removes the item
            }));
            
            // Timeout after 5 seconds
            setTimeout(() => {
              window.removeEventListener('message', handleMessage);
              resolve(false);
            }, 5000);
          });
        } else if (window.ReactNativeWebView) {
          // Use AsyncStorage via React Native messages
          return new Promise((resolve) => {
            const callbackId = `remove_${Date.now()}_${Math.random()}`;
            
            const handleMessage = (event) => {
              try {
                const response = JSON.parse(event.data);
                if (response.type === 'storysdk:storage:response' && response.callbackId === callbackId) {
                  window.removeEventListener('message', handleMessage);
                  resolve(response.data.success || false);
                }
              } catch (e) {
                // Ignore parsing errors
              }
            };
            
            window.addEventListener('message', handleMessage);
            
            window.ReactNativeWebView.postMessage(JSON.stringify({
              type: 'storysdk:storage:set',
              callbackId: callbackId,
              data: { key, value: null } // Setting to null removes the item
            }));
            
            // Timeout after 5 seconds
            setTimeout(() => {
              window.removeEventListener('message', handleMessage);
              resolve(false);
            }, 5000);
          });
        } else {
          // Fallback to localStorage
          try {
            localStorage.removeItem(key);
            return true;
          } catch (e) {
            return false;
          }
        }
      }
    };

    // Cache request and check cache validity by version
    async function fetchWithCache(url, cacheKey, options = {}) {
      // Check storage for cached script
      try {
        const cached = await StorageProxy.getItem(cacheKey);
        
        if (cached) {
          const { timestamp, content, version } = JSON.parse(cached);
          
          // If version matches and cache is not older than 24 hours, use it
          if (version === BUNDLE_VERSION && Date.now() - timestamp < 24 * 60 * 60 * 1000) {
            debug('Using cached resource:', url);
            return content;
          }
        }
      } catch (e) {
        debug('Cache reading error:', e);
      }
      
      // If cache doesn't exist or is outdated, load again
      try {
        debug('Fetching resource:', url);
        const response = await fetch(url, options);
        
        if (!response.ok) {
          throw new Error(`Failed to fetch: ${response.status} ${response.statusText}`);
        }
        
        const content = await response.text();
        
        // Save to cache
        try {
          await StorageProxy.setItem(cacheKey, JSON.stringify({
            timestamp: Date.now(),
            content,
            version: BUNDLE_VERSION
          }));
        } catch (e) {
          debug('Cache writing error:', e);
        }
        
        return content;
      } catch (error) {
        debug('Fetch error:', error);
        throw error;
      }
    }

    async function loadSDKScript(mode) {
      return new Promise((resolve, reject) => {
        if (typeof window.Story === 'function') {
          debug('SDK already loaded');
          resolve(true);
          return;
        }

        let scriptUrl = `https://cdn.jsdelivr.net/npm/@storysdk/core@${BUNDLE_VERSION}/dist/bundle.umd.js`;
        
        if (mode === 'development') {
          const possibleUrls = [
            'http://localhost:3003/bundle.umd.js',
            'http://127.0.0.1:3003/bundle.umd.js',
            'http://10.0.2.2:3003/bundle.umd.js', // Android 
            'http://10.0.3.2:3003/bundle.umd.js'  // Genymotion
          ];
          
          debug('Development mode: trying multiple localhost URLs');
          postMessageToReactNative('storysdk:debug:info', {
            message: 'Attempting to load development script',
            urls: possibleUrls,
            userAgent: navigator.userAgent,
            location: window.location.href
          });
          
          // Try development URLs first, then fallback to production
          tryMultipleUrls(possibleUrls, resolve, reject, scriptUrl);
          return;
        } else if( mode === 'production') {
        // Use caching for production version
        fetchWithCache(scriptUrl, SCRIPT_CACHE_KEY)
          .then(scriptContent => {
            try {
              // Create and execute script
              const script = document.createElement('script');
              script.text = scriptContent;
              document.head.appendChild(script);
              
              if (typeof window.Story === 'function') {
                debug('SDK script loaded successfully');
                resolve(true);
              } else {
                debug('Story constructor not available after script load');
                reject(new Error('Story constructor not available after script load'));
              }
            } catch (error) {
              debug('Error executing script:', error);
              // If an error occurs, try traditional loading method
              loadScriptDirect(scriptUrl, resolve, reject);
            }
          })
          .catch(error => {
            debug('Error fetching script:', error);
            // If failed to load via fetch, try traditional method
            loadScriptDirect(scriptUrl, resolve, reject);
          });
        }
      });
    }
  
    async function tryMultipleUrls(urls, resolve, reject, fallbackUrl = null) {
      let lastError = null;
      
      for (let i = 0; i < urls.length; i++) {
        const url = urls[i];
        try {
          debug(`Trying URL ${i + 1}/${urls.length}:`, url);
          postMessageToReactNative('storysdk:debug:info', {
            message: `Trying to load script from URL ${i + 1}/${urls.length}`,
            url: url
          });
          
          await new Promise((resolveUrl, rejectUrl) => {
            loadScriptDirect(url, resolveUrl, rejectUrl);
          });
          
          debug('Successfully loaded from:', url);
          postMessageToReactNative('storysdk:debug:info', {
            message: 'Successfully loaded development script',
            url: url
          });
          resolve(true);
          return;
        } catch (error) {
          debug(`Failed to load from ${url}:`, error);
          lastError = error;
          
          postMessageToReactNative('storysdk:debug:info', {
            message: `Failed to load from URL ${i + 1}/${urls.length}`,
            url: url,
            error: error.message
          });

          if (i < urls.length - 1) {
            continue;
          }
        }
      }

      debug('All development URLs failed, last error:', lastError);
      postMessageToReactNative('storysdk:debug:info', {
        message: 'All development URLs failed',
        lastError: lastError?.message
      });
      
      // Try fallback to production URL if provided
      if (fallbackUrl) {
        debug('Falling back to production URL:', fallbackUrl);
        postMessageToReactNative('storysdk:debug:info', {
          message: 'Falling back to production script',
          url: fallbackUrl
        });
        
        try {
          // Use caching for production version
          const scriptContent = await fetchWithCache(fallbackUrl, SCRIPT_CACHE_KEY);
          const script = document.createElement('script');
          script.text = scriptContent;
          document.head.appendChild(script);
          
          if (typeof window.Story === 'function') {
            debug('SDK script loaded successfully from production fallback');
            postMessageToReactNative('storysdk:debug:info', {
              message: 'Successfully loaded production script as fallback'
            });
            resolve(true);
            return;
          } else {
            debug('Story constructor not available after production script load');
            throw new Error('Story constructor not available after production script load');
          }
        } catch (fallbackError) {
          debug('Production fallback also failed:', fallbackError);
          postMessageToReactNative('storysdk:debug:info', {
            message: 'Production fallback also failed',
            error: fallbackError.message
          });
          
          // Try direct loading as last resort
          try {
            await new Promise((resolveUrl, rejectUrl) => {
              loadScriptDirect(fallbackUrl, resolveUrl, rejectUrl);
            });
            
            debug('Successfully loaded production script via direct loading');
            resolve(true);
            return;
          } catch (directError) {
            debug('Direct loading of production script also failed:', directError);
          }
        }
      }
      
      reject(lastError || new Error('All script URLs failed'));
    }

    function loadScriptDirect(url, resolve, reject) {
      const script = document.createElement('script');

      // Reduce timeout for development URLs to fail faster
      const isDevelopmentUrl = url.includes('localhost') || url.includes('127.0.0.1') || 
                              url.includes('10.0.2.2') || url.includes('10.0.3.2');
      const timeoutDuration = isDevelopmentUrl ? 3000 : 10000; // 3s for dev, 10s for production

      const timeout = setTimeout(() => {
        script.remove();
        const errorDetails = {
          message: 'Script loading timeout',
          url: url,
          timeout: `${timeoutDuration}ms`,
          isDevelopmentUrl: isDevelopmentUrl
        };
        debug('Script loading timeout:', errorDetails);
        postMessageToReactNative('storysdk:debug:info', errorDetails);
        reject(new Error(`Script loading timeout: ${url}`));
      }, timeoutDuration);
      
      script.onerror = (error) => {
        clearTimeout(timeout);
        script.remove();
        const errorDetails = {
          message: 'Failed to load SDK script',
          url: url,
          details: error.message || 'Network error or CORS issue'
        };
        debug('Script loading error:', errorDetails);
        postMessageToReactNative('storysdk:debug:info', errorDetails);
        reject(new Error(`Failed to load script: ${url}`));
      };
      
      script.onload = () => {
        clearTimeout(timeout);
        debug('Script loaded successfully from:', url);
        
        // Give the script a moment to execute
        setTimeout(() => {
          if (typeof window.Story === 'function') {
            debug('Story constructor available after script load');
            resolve(true);
          } else {
            const errorDetails = {
              message: 'Story constructor not available after script load',
              url: url,
              windowKeys: Object.keys(window).filter(k => k.toLowerCase().includes('story')),
              globalStory: typeof window.Story,
              globalStorysdk: typeof window.storysdk
            };
            debug('Story constructor not available:', errorDetails);
            postMessageToReactNative('storysdk:debug:info', errorDetails);
            reject(new Error('Story constructor not available after script load'));
          }
        }, 100); // Give 100ms for script execution
      };

      if (url.startsWith('http://localhost') || url.startsWith('http://127.0.0.1') || 
          url.startsWith('http://10.0.2.2') || url.startsWith('http://10.0.3.2')) {
        debug('Loading local development script without crossOrigin');
      } else {
        script.crossOrigin = 'anonymous';
      }
      
      script.src = url;
      document.head.appendChild(script);
      
      debug('Script tag added to head:', {
        src: script.src,
        crossOrigin: script.crossOrigin
      });
    }

    async function initSDK(options) {
      try {
        // Check if token changed - if so, force reinitialization
        const initCurrentToken = options.token;
        const initPreviousToken = window.__STORYSDK_PREVIOUS_TOKEN__;
        const tokenChanged = initPreviousToken && initPreviousToken !== initCurrentToken;
        
        // If SDK is initialized and token changed, we can just update the token
        if (window.__STORYSDK_INITIALIZED__ && tokenChanged && window.__STORYSDK_INSTANCE__) {
          debug('Token changed from', initPreviousToken, 'to', initCurrentToken, ', updating existing instance...');
          // Continue with token update instead of full reinitialization
        }
        // Prevent multiple initializations unless token changed
        else if (window.__STORYSDK_INITIALIZED__ && !tokenChanged) {
          debug('SDK already initialized with same token, skipping...');
          return;
        }
        
        if (tokenChanged && !window.__STORYSDK_INSTANCE__) {
          debug('Token changed but no instance exists, forcing full reinitialization...');
          window.__STORYSDK_INITIALIZED__ = false;
        }
        
        window.__STORYSDK_INITIALIZED__ = true;
        window.STORYSDK_DEBUG = options.isDebugMode || false;
        window.__STORYSDK_USE_ASYNC_STORAGE_ONLY__ = options.useAsyncStorageOnly || false;
        debug('Starting SDK initialization with options:', options);
        
        // Send debug info about platform and environment
        postMessageToReactNative('storysdk:debug:info', {
          message: 'SDK initialization started',
          platform: options.platform || 'unknown',
          devMode: options.devMode,
          isInReactNativeWebView: options.isInReactNativeWebView,
          disableCache: options.disableCache,
          isOnlyGroups: options.isOnlyGroups,
          userAgent: navigator.userAgent,
          location: window.location.href,
          protocol: window.location.protocol
        });
        
        if (options.devMode === 'development') {
          postMessageToReactNative('storysdk:debug:info', {
            message: 'Development mode detected - will attempt HTTP script loading',
            networkState: navigator.onLine ? 'online' : 'offline'
          });
        }
        
        checkBrowserCompatibility();

        if (!options || !options.token) {
          throw new Error('SDK token not specified');
        }

        // CRITICAL: Clear Web SDK cache when token changes
        // Store previous token for comparison  
        const currentToken = options.token;
        const previousToken = window.__STORYSDK_PREVIOUS_TOKEN__;
        
        if (previousToken && previousToken !== currentToken) {
          debug('Token changed, clearing Web SDK cache...');
          
          // Clear Web SDK cache for old token
          const previousTokenHash = simpleHash(previousToken);
          await clearTokenCache(previousTokenHash);
          
          // Also clear main Web SDK cache keys including all API cache
          if (window.ReactNativeWebView) {
            // Send message to React Native to clear cache by patterns
            postMessageToReactNative('storysdk:cache:clear:patterns', {
              patterns: [
                `storysdk_api_cache_${previousToken}_*`,
                `storysdk_adapted_${previousToken}_*`,
                `storysdk_adapted_data_${previousToken}_*`,
                `storysdk_groups_${previousToken}_*`,
                `storysdk_stories_${previousToken}_*`,
                `storysdk_app_${previousToken}_*`,
                'storysdk_groups_data_*',
                'storysdk_stories_data_*',
                'storysdk_answers_*',
                'storysdk_api_cache_*'
              ]
            });
          } else {
            // Fallback to localStorage
            try {
              const webSdkKeysToRemove = [];
              for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && (
                  key.startsWith(`storysdk_api_cache_${previousToken}_`) ||
                  key.startsWith(`storysdk_adapted_${previousToken}_`) ||
                  key.startsWith(`storysdk_adapted_data_${previousToken}_`) ||
                  key.startsWith(`storysdk_groups_${previousToken}_`) ||
                  key.startsWith(`storysdk_stories_${previousToken}_`) ||
                  key.startsWith(`storysdk_app_${previousToken}_`) ||
                  key.startsWith('storysdk_groups_data_') ||
                  key.startsWith('storysdk_stories_data_') ||
                  key.startsWith('storysdk_answers_') ||
                  // Clear all API cache to force fresh data loading
                  key.startsWith('storysdk_api_cache_')
                )) {
                  webSdkKeysToRemove.push(key);
                }
              }
              webSdkKeysToRemove.forEach(key => localStorage.removeItem(key));
              debug('Cleared Web SDK cache keys:', webSdkKeysToRemove.length);
            } catch (e) {
              debug('Error clearing Web SDK cache:', e);
            }
          }
          
          // Reset SDK state to ensure fresh initialization
          if (window.Story && typeof window.Story.reset === 'function') {
            try {
              window.Story.reset();
              debug('Reset Web SDK state');
            } catch (e) {
              debug('Error resetting Web SDK state:', e);
            }
          }
        }
        
        // Store current token for next comparison
        window.__STORYSDK_PREVIOUS_TOKEN__ = currentToken;

        // CRITICAL: Force update axios headers immediately to ensure correct token
        if (typeof axios !== 'undefined' && currentToken) {
          try {
            axios.defaults.headers.common = { Authorization: `SDK ${currentToken}` };
            debug('Force updated axios headers with current token:', currentToken);
          } catch (e) {
            debug('Failed to update axios headers:', e);
          }
        }

        // Force cache clearing if disableCache is enabled
        if (options.disableCache) {
          debug('disableCache option enabled, clearing all Web SDK cache...');
          // When disableCache is used, clear everything including tokens
          await clearAllSDKCache(false); // don't preserve tokens for disableCache
          
          // Force reset SDK initialization state to ensure fresh load
          if (window.__STORYSDK_INITIALIZED__) {
            window.__STORYSDK_INITIALIZED__ = false;
          }
          if (window.__STORYSDK_PREVIOUS_TOKEN__) {
            delete window.__STORYSDK_PREVIOUS_TOKEN__;
          }
        }

        // Update cache keys with token to isolate cache by token
        updateCacheKeys(options.token);

        const loaded = await loadSDKScript(options.devMode || 'production');
        if (!loaded) {
          throw new Error('Failed to load SDK');
        }
        
        const safeOptions = {
          token: options.token,
          ...options,
          isInReactNativeWebView: true,
          devMode: 'production'
        };

        postMessageToReactNative('init', safeOptions);

        if (typeof window.Story !== 'function') {
          throw new Error('Story constructor not available');
        }
        
        const container = document.getElementById('storysdk-container');
        if (!container) {
          throw new Error('Container not found');
        }

        // Force container to be completely clean
        container.innerHTML = '';
        container.className = 'storysdk-container';
        
        // Add unique data attribute based on token to help with debugging
        container.setAttribute('data-token', safeOptions.token.substring(0, 8));

        // CRITICAL: Always create fresh instance when token changes - don't try to update existing
        if (window.__STORYSDK_INSTANCE__) {
          debug('Token changed, destroying existing Story instance and creating new one');
          
          try {
            // Destroy existing instance
            if (typeof window.__STORYSDK_INSTANCE__.destroy === 'function') {
              window.__STORYSDK_INSTANCE__.destroy();
            }
            
            // Clear the container completely
            if (container) {
              container.innerHTML = '';
              // Remove all event listeners
              const newContainer = container.cloneNode(false);
              container.parentNode.replaceChild(newContainer, container);
              container = newContainer;
            }
            
            // Remove global reference
            delete window.__STORYSDK_INSTANCE__;
            debug('Successfully destroyed existing Story instance');
          } catch (error) {
            debug('Error destroying existing instance:', error);
            // Continue with fresh creation anyway
            delete window.__STORYSDK_INSTANCE__;
          }
        }

        // Add small delay to ensure DOM is fully ready after cleanup
        await new Promise(resolve => setTimeout(resolve, 100));

        const storySDK = new window.Story(safeOptions.token, safeOptions);
        // Store global reference for token updates
        window.__STORYSDK_INSTANCE__ = storySDK;
        
        //Timeout to prevent infinite waiting
        let dataLoadedTimeout;
        let dataLoadedReceived = false;
        
        // Clear timeout on successful load
        const clearDataLoadedTimeout = () => {
          if (dataLoadedTimeout) {
            clearTimeout(dataLoadedTimeout);
            dataLoadedTimeout = null;
          }
        };
        
        // Set 10 second timeout
        dataLoadedTimeout = setTimeout(() => {
          if (!dataLoadedReceived) {
            debug('DataLoaded timeout - SDK failed to load data within 10 seconds');
            postMessageToReactNative('error', {
              message: 'SDK initialization timeout',
              details: 'Failed to load data within 10 seconds. The group may not exist or there may be network issues.'
            });
          }
        }, 10000);
        
        storySDK.on('dataLoaded', () => {
          dataLoadedReceived = true;
          clearDataLoadedTimeout();
          
          postMessageToReactNative('init:success', { 
            message: 'StorySDK initialized and data loaded successfully'
          });
          const finalHeight = container.scrollHeight || container.offsetHeight || 110;
          postMessageToReactNative('content:height', { height: finalHeight });
        });
        
        // Add error handling
        storySDK.on('error', (errorData) => {
          dataLoadedReceived = true;
          clearDataLoadedTimeout();
          postMessageToReactNative('error', {
            message: 'StorySDK error',
            details: errorData
          });
        });
        
        debug('Rendering groups with token:', safeOptions.token);
        storySDK.renderGroups(container);
        
        // Debug container state after render
        setTimeout(() => {
          debug('Container state after render:', {
            token: safeOptions.token.substring(0, 8),
            innerHTML: container.innerHTML.length,
            children: container.children.length,
            height: container.offsetHeight
          });
        }, 1000);

        // Observe container size changes
        if (window.ResizeObserver) {
          let lastReportedHeight = 0;
          const resizeObserver = new ResizeObserver((entries) => {
            for (const entry of entries) {
              const actualHeight = entry.contentRect.height || entry.target.scrollHeight || 110;
              // Only report height changes if they are significant (more than 1px difference)
              if (Math.abs(actualHeight - lastReportedHeight) > 1) {
                lastReportedHeight = actualHeight;
                postMessageToReactNative('content:height', { height: actualHeight });
                debug('ResizeObserver: Height changed to', actualHeight);
              }
            }
          });
          resizeObserver.observe(container);
        }

        const events = [
          'groupClose',
          'groupOpen',
          'storyClose',
          'storyOpen',
          'storyNext',
          'storyPrev',
          'widgetAnswer',
          'widgetClick',
          'storyModalOpen',
          'storyModalClose',
          'groupClick'
        ];

        events.forEach(eventName => {
          storySDK.on(eventName, (data) => {
            debug(`Event ${eventName}:`, data);
            postMessageToReactNative(eventName, data);
          });
        });

      } catch (error) {
        debug('SDK initialization error:', error);
        
        // Reset initialization flag on error to allow retry
        window.__STORYSDK_INITIALIZED__ = false;

        postMessageToReactNative('error', { 
          message: 'Failed to initialize SDK',
          details: error.message
        });
      }
    }

    window.addEventListener('message', async function(event) {
      try {
        // Handle both string and object data for better Android compatibility
        let messageData;
        if (typeof event.data === 'string') {
          messageData = JSON.parse(event.data);
        } else {
          messageData = event.data;
        }
        
        debug('Message received:', messageData);
        
        if (messageData.type === 'init') {
          const options = messageData.options || messageData.data;
          debug('Initializing SDK with options:', options);
          await initSDK(options);
        } else if (messageData.type === 'storysdk:cache:clear') {
          const tokenHash = messageData.data?.tokenHash;
          if (tokenHash) {
            await clearTokenCache(tokenHash);
          }
          // Send response back
          postMessageToReactNative('storysdk:cache:cleared', {
            success: true,
            tokenHash: tokenHash
          });
        } else if (messageData.type === 'storysdk:cache:clear:all') {
          // Clear ALL SDK cache - more aggressive approach
          // Check if tokens should be preserved
          const preserveTokens = messageData.data?.preserveTokens || false;
          await clearAllSDKCache(preserveTokens);
          // Send response back
          postMessageToReactNative('storysdk:cache:cleared:all', {
            success: true,
            preserveTokens: preserveTokens
          });
        } else if (messageData.type === 'storysdk:cache:clear:token') {
          // Clear cache by token hash
          const tokenHash = messageData.data?.tokenHash;
          if (tokenHash) {
            await clearTokenCache(tokenHash);
          }
          postMessageToReactNative('storysdk:cache:cleared:token', {
            success: true,
            tokenHash: tokenHash
          });
        } else if (messageData.type === 'storysdk:cache:clear:patterns') {
          // Clear cache by patterns - forwarded to React Native
          postMessageToReactNative('storysdk:cache:clear:patterns:request', {
            patterns: messageData.data?.patterns || []
          });
        }
      } catch (error) {
        debug('Error processing message:', error);
        postMessageToReactNative('error', { 
          message: 'Error processing message',
          details: error.message
        });
      }
    });

    function sendWebviewReady() {
      if (window.__STORYSDK_WEBVIEW_READY_SENT__) {
        return;
      }
      
      window.__STORYSDK_WEBVIEW_READY_SENT__ = true;

      postMessageToReactNative('webview:ready', {
        protocol: window.location.protocol,
        userAgent: navigator.userAgent
      });
    }

    window.addEventListener('DOMContentLoaded', sendWebviewReady);
    
    if (document.readyState === 'interactive' || document.readyState === 'complete') {
      sendWebviewReady();
    }
  </script>
</body>
</html> 